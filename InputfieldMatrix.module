<?php

/**
* InputfieldMatrix for ProcessWire.
*
* This Inputfield is a GUI for FieldtypeMatrix.
*
* @author Kongondo <kongondo@gmail.com>
* @author Ryan Cramer 
* 
* Largely based on original code from Ryan Cramer's FieldtypeEvnents. 
*
* Lincensed under GNU/GPL v2.
*
* https://github.com/kongondo/FieldtypeMatrix
* Created December 2014
* 
* ProcessWire 2.x
* Copyright (C) 2011 by Ryan Cramer
* Licensed under GNU/GPL v2, see LICENSE.TXT
*
* http://www.processwire.com
*
*/

class InputfieldMatrix extends Inputfield {

	public static function getModuleInfo() {
		return array(
			'title' => 'Matrix',
			'author' => 'Kongondo',
			'version' => 1,
			'href' => 'https://processwire.com/talk/topic/1234-xxxx/',
			'summary' => 'Input field for a 2D-matrix.',
			'requires' => 'FieldtypeMatrix', 
			);
	}

	protected $page;
	protected $field; 

	public function setPage(Page $page) {
		
		$this->page = $page; 
	}

	public function setField(Field $field) {

		$this->field = $field;
	}

	/**
	 * Render the entire input area for a Matrix
	 *
	 */
	public function ___render() {

		//get our saved matrix values
		$values = $this->attr('value');
		$pages = wire('pages');
		$dbMatrix = array();//for storing row/column values already saved in db

		foreach($values as $m) {
						
						//remove matrix-rows that are no longer needed i.e. 'unpublished', 'hidden', 'deleted' or 'trashed'
						$rp = $pages->get($m->matrix_row);
						if (!$rp || $rp->is(Page::statusUnpublished) || $rp->isHidden() || $rp->isTrash()) continue;
						//if (!$rp || $rp->is('unpublished') || $rp->is('hidden')) continue;//syntax will only work in PW 2.5+ ?

						$dbMatrix[$m->matrix_row][$m->matrix_column] = $m->matrix_value;

						//remove matrix-columns that are no longer needed i.e. 'unpublished', 'hidden', 'deleted' or 'trashed'
						$cp = $pages->get($m->matrix_column);
						if (!$cp || $cp->is(Page::statusUnpublished) || $cp->isHidden() || $cp->isTrash()) unset($dbMatrix[$m->matrix_row][$m->matrix_column]);

		}
		
		//creat our default matrix with blank values (i.e. blank matrix->value)
		$defaultMatrix = array();
		
		$rowSelector = $this->rows;//this property was set in FieldtypeMatrix getInputfield()
		$columnSelector = $this->columns;//this property was set in FieldtypeMatrix getInputfield()
		
		
		$editURL = $this->wire('config')->urls->admin . 'setup/field/edit?id=' . $this->field->id;

		//@@todo - use error instead?
		if(!$rowSelector || !$columnSelector) return '<h4>You need to input selectors to find pages to show in your matrix table. See this <a href="' . $editURL .'">Field\'s Details Tab.</a></h4>';

		//find all matrix-row pages
		$rows = $pages->find($rowSelector); //pw will throw an exception here if the selector is not valid

		//find all matrix-column pages
		$columns = $pages->find($columnSelector); //pw will throw an exception here if the selector is not valid
		

		//throw error if row selector returns empty!
		if (!count($rows)) {
					$this->error($this->_('No row pages found with the selector set in \'Row Matrix pages\' for this Field. Amend your selector.'));
					return '<h4>Rows selector did not find any results!</h4>';
		}

		//throw error if column selector returns empty!
		if (!count($columns)) {
					$this->error($this->_('No column pages found with the selector set in \'Column Matrix\' pages for this Field. Amend your selector.'));
					return '<h4>Columns selector did not find any results!</h4>';
		}
		
		//get the rows and columns to build our empty-values default matrix
		foreach($rows as $row) {

					//create our rows - top level array
					$defaultMatrix[$row->id] = '';

					//create our columns - 2nd level array WITH empty values
					foreach ($columns as $column) {
								
								$defaultMatrix[$row->id][$column->id] = '';//value = blank
					}

		}

		//#########	CREATE MATRIX TABLE #########

		//prepare our final matrix to output to page edit Input
		//we recursively replace defaultMatrix blank values with dbMatrix values where applicable (matched array keys)
		//'new' (i.e. not in $dbMatrix) default row/column combinations are preserved and added to final matrix
		//note: values previously saved using a different selector will still be present!
		//as long as their respective pages have not been deleted/trashed/hid/unpublished
		$mergedMatrix = array_replace_recursive($defaultMatrix, $dbMatrix);		

		$tbody ='';//for matrix rows
		$thcols = '';//for matrix table column headers
		$rowHeaderLabel = $this->rowLabelFieldName;//this property was set in FieldtypeMatrix getInputfield()
		$columnHeaderLabel = $this->columnLabelFieldName;//this property was set in FieldtypeMatrix getInputfield()
		//@@todo - saved $columnHeaderLabler not being displayed as selected in Details tab! But value is correctly saved in db

		$i = 0;//set counter not to output extraneous column label headers
		//$j = 1;//counter for rows numbering
		foreach ($mergedMatrix as $row => $cols) {

		            //matrix table row headers (first column)
					$rh = $pages->get($row);
		            #$tbody .= "<tr><td><strong>" . $pages->get($row)->title . "</strong></td>";
					
					//if we have a row label from selected field show it otherwise show title
		            $rowLabel = $rh->$rowHeaderLabel ? $rh->$rowHeaderLabel : $rh->title;
		           /*$tbody .= "<tr>
									<td class=MatrixRowCount>" . $j. "</td>
		            				<td>" . $rowLabel. "</td>";*///@@left here in case will switch to row counters in the future

		            $tbody .= "<tr><td class='MatrixRowHeader'>" . $rowLabel . "</td>";

		            $count = count($cols);//help to stop output of extra/duplicate column headers

		            foreach ($cols as $col => $value) {

				            	//matrix table column headers
		            			$ch = $pages->get($col);

		            			//if we have a column label from selected field show it otherwise show title
		            			$columnLabel = $ch->$columnHeaderLabel ? $ch->$columnHeaderLabel : $ch->title;
				            	//avoid outputting extra duplicate columns
				            	if ($i < $count) $thcols .= "<th class='MatrixColumnHeader'>" . $columnLabel . "</th>";
				            		
				                //input name will be in the format 'R5282_C5289' to match row and column page IDs respectively
				                #$tbody .= "<td><input type='text' name='matrix[R" . $rh->id . "_C" . $ch->id . "]' value='" . $value . "'></td>";
				                $tbody .= "<td><input type='text' name='matrix_" . $this->field->name. "[R" . $rh->id . "_C" . $ch->id . "]' value='" . $value . "'></td>";
				             	
				             	$i++;

		            }

		            $tbody .= "</tr>";

		            //$j++;
		}

		//final matrix table for output
		 $out =   "<table class='InputfieldMatrix'>
		                <thead>
		                  <tr class=''>
		                    <th></th>
		                    $thcols
		                   </tr>
		                </thead>
		                <tbody>
		                  $tbody
		                </tbody>
		            </table>";


		return $out; 
	}

	/**
	 * Process input for the values sent from the Matrix table for this page
	 *
	 */
	public function ___processInput(WireInputData $input) {

			if(!$this->page || !$this->field) {
				throw new WireException("This inputfield requires that you set valid 'page' and 'field' properties to it."); 
			}

			$name = 'matrix_' . $this->attr('name');

			$matrices = $this->field->type->getBlankValue($this->page, $this->field);

			foreach ($input->{"{$name}"} as $key => $value) {

					//$key is in the format R1234_C1234 reflecting row and column pages' IDs respectively
						
					//create a new matrix and add it to our matrices
					$m = new Matrix();

					$rowCol = explode('_', $key);//[0]=>R1234, [1]=>C1234

					$row = str_replace('R', NULL, $rowCol[0]);//clean row page ID
					$column = str_replace('C', NULL, $rowCol[1]);//clean column page ID

					$m->matrix_row = (int) $row;//@@todo - don't really need to sanitize here as well since done in Matrix::set() too?
					$m->matrix_column = (int) $column;//@@todo - ditto
					$m->matrix_value = $value;

					$matrices->add($m);//add matrix to MatrixArray

			}//end foreach
		
		//if the string values of the processed matrices are different from the previous,
		//or if any matrices have been deleted, then flag this Inputfield as changed
		//so that it will be automatically saved with the page
		
		//if things have changed, we take the new values
		if("$matrices" != "$this->value") {
			
				$this->attr('value', $matrices); 
				$this->trackChange('value'); 
		}
		

	}


}

