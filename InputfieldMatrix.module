<?php

/**
* InputfieldMatrix for ProcessWire.
*
* This Inputfield is a GUI for FieldtypeMatrix.
*
* @author Kongondo <kongondo@gmail.com>
* @author Ryan Cramer 
* 
* Largely based on original code from Ryan Cramer's FieldtypeEvnents. 
*
* Lincensed under GNU/GPL v2.
*
* https://github.com/kongondo/FieldtypeMatrix
* Created December 2014
* 
* ProcessWire 2.x
* Copyright (C) 2011 by Ryan Cramer
* Licensed under GNU/GPL v2, see LICENSE.TXT
*
* http://www.processwire.com
*
*/

class InputfieldMatrix extends Inputfield {

	public static function getModuleInfo() {
		return array(
			'title' => 'Matrix',
			'author' => 'Kongondo',
			'version' => 7,
			'href' => 'https://processwire.com/talk/topic/8581-module-matrix-fieldtype-inputfield/',
			'summary' => 'Input field for a 2D-matrix.',
			'requires' => 'FieldtypeMatrix', 
			);
	}

	protected $page;
	protected $field;

	public function setPage(Page $page) {
		
		$this->page = $page; 
	}

	public function setField(Field $field) {

		$this->field = $field;
	}	

	/**
	 * Build an array for outputting a Matrix Table/Grid
	 *
	 */
	public function mergeMatrix() {

		//prepare some variables
		$values = $this->attr('value');
		$pages = wire('pages');
		$page = $this->page;
		$rowsParent = '';
		$columnsParent = '';
		
		$parentRowColumnSelector = $this->parentRowColumnFieldName;//this property was set in FieldtypeMatrix getInputfield()
		$rowSelector = $this->rowSelector;//this property was set in FieldtypeMatrix getInputfield()
		$columnSelector = $this->columnSelector;//this property was set in FieldtypeMatrix getInputfield()
		
		$editURL = $this->wire('config')->urls->admin . 'setup/field/edit?id=' . $this->field->id;
		
		### first we deal with errors. We'll return these as strings to oupput in $this->error() in render() ###

		//in neither a Page Field nor selectors for finding pages to build matrix rows/columns specified set error message
		if((!$parentRowColumnSelector) && (!$rowSelector || !$columnSelector))
				return '<a href="' . $editURL .'">' . 	$this->_('Check the Details Tab of the field') . '</a> ' . $this->field->name . 
														$this->_('. You need to either use selectors or a Page Field to find pages to show in your matrix table.');

		//if Page Field specified, we use that to find the children pages of the specified row and column parent pages respectively
		if($parentRowColumnSelector) {
				//if the page field does not return a PageArray, set error message	
				if(!$page->$parentRowColumnSelector instanceof PageArray)
					return '<a href="' . $editURL .'">' . 	$this->_('Check the Details Tab of the field') . '</a> ' . $this->field->name . 
															$this->_('. Only a Page Field can be used to specify the rows and columns parent pages for building your matrix! Confirm that you specified a Multiplepage Field.');

				//if less than 2 matrix parent pages selected (we need one for rows and the other for columns) set error message
				if(count($page->$parentRowColumnSelector) < 2) return $this->_('You need to select 1 matrix rows parent and 1 matrix columns parent.');

				### rows parent ###
				$rowsParent = $page->$parentRowColumnSelector->first();//the first selected page is treated as the row pages parent
				
				//if for some reason specified $rowsParent does not exist set error message
				if(!$rowsParent) return $this->_('The specified matrix row parent page was not found. Confirm it exists or specify another.');
				
				//if $rowsParent does not have children set error message
				if(!$rowsParent->numChildren) return $this->_('The specified matrix rows parent does not have children. You need to first create its child pages.');

				#### columns parent ####
				$columnsParent = $page->$parentRowColumnSelector->getNext($rowsParent);//the second selected page is treated as the column pages parent

				//if for some reason specified $columnsParent does not exist set error message
				if(!$columnsParent) return $this->_('The specified matrix columns parent page was not found. Confirm it exists or specify another.');
				
				//if $columnsParent does not have children set error message
				if(!$columnsParent->numChildren) return $this->_('The specified matrix column parent does not have children. You need to first create its child pages.');
				
				##### -if we made it here, we are good to go ####
				//find all matrix-row pages
				$rows = $rowsParent->children;

				//find all matrix-column pages
				$columns = $columnsParent->children;
	
		}//end if a Page Field was specified

		//if Page Field NOT specified, we use specified row/column selectors instead
		else {

				//find all matrix-row pages
				$rows = $pages->find($rowSelector);//ProcessWire will throw an exception here if the selector is not valid

				//find all matrix-column pages
				$columns = $pages->find($columnSelector);//ProcessWire will throw an exception here if the selector is not valid

				//if row/column selectors return empty set error message
				if(!count($rows)) 
					return 	$this->_('No row pages found with the selector set in \'Row Matrix pages\' for the field ') . $this->field->name . 
							'. <a href="' . $editURL .'">' . 	$this->_('Amend your selector') . '</a>.';
				
				if(!count($columns)) 
					return 	$this->_('No column pages found with the selector set in \'Column Matrix pages\' for the field ') . $this->field->name . 
							'. <a href="' . $editURL .'">' . 	$this->_('Amend your selector') . '</a>.';

		}//end else we use row/column selectors

		//create our default matrix with blank values (i.e. blank matrix->value)
		//we later merge this with saved values in the db
		//this will help us detect if new row/column pages have been added
		$defaultMatrix = array();

		//get the rows and columns to build our empty-values default matrix
		foreach($rows as $row) {

				//create our rows - top level array
				#$defaultMatrix[$row->id] = '';//no need for this here

				//create our columns - 2nd level array WITH empty values
				foreach($columns as $column) {
							
							$defaultMatrix[$row->id][$column->id] = '';//value = blank
				}

		}

		//get our saved db matrix values
		$dbMatrix = array();//for storing row/column values already saved in db

		//loop through saved db vakues
		foreach($values as $m) {

				//get the row page
				$rp = $pages->get($m->matrix_row);
				
				//in case the matrix rows parent was changed and is different from the rows parent of the saved db values...
				//we skip such rows in readiness for deletion
				//we only do this if a Page Field was used to select matrix rows (difficult if a selector was used - no problem since assuming only supersuser can edit selector in Page Field)
				if($rowsParent && $rp->parent != $rowsParent) continue;

				//remove matrix-rows that are no longer needed i.e. 'unpublished', 'hidden', 'deleted' or 'trashed'
				if(!$rp || $rp->is(Page::statusUnpublished) || $rp->isHidden() || $rp->isTrash()) continue;
				//if(!$rp || $rp->is('unpublished') || $rp->is('hidden')) continue;//syntax will only work in PW 2.5+ ?

				//build the saved values array
				#$dbMatrix[$m->matrix_row][$m->matrix_column] = $m->matrix_value;//
				$dbMatrix[$m->matrix_row][$m->matrix_column] = $this->sanitizer->entities($m->matrix_value);//@@todo - need to sanitize this values for display?

				//get the column page
				$cp = $pages->get($m->matrix_column);

				//remove matrix-columns that are no longer needed i.e. 'unpublished', 'hidden', 'deleted' or 'trashed'
				if(!$cp || $cp->is(Page::statusUnpublished) || $cp->isHidden() || $cp->isTrash()) unset($dbMatrix[$m->matrix_row][$m->matrix_column]);
				
				//in case the matrix columns parent was changed and is different from the columns parent of the saved db values...
				//we remove such columns in readiness for deletion
				//we only do this if a Page Field was used to select matrix columns (ditto above)
				if($columnsParent && $cp->parent != $columnsParent) unset($dbMatrix[$m->matrix_row][$m->matrix_column]);

		}

		//prepare our final matrix to output to page (edit) InputfieldMatrix
		//we recursively replace defaultMatrix blank values with dbMatrix values where applicable (matched array keys)
		//'new' (i.e. not in $dbMatrix) default row/column combinations are preserved and added to final matrix
		//note: values previously saved using a different selector will still be present!...
		//as long as their respective pages have not been deleted/trashed/hid/unpublished
		$mergedMatrix = array_replace_recursive($defaultMatrix, $dbMatrix);

		return $mergedMatrix;//matrix array

	}

	/**
	 * Render the entire input area for a Matrix
	 *
	 */
	public function ___render() {

		//#########	CREATE MATRIX TABLE #########

		$mergedMatrix = $this->mergeMatrix();

		//if we didn't get an array back from $mergeMatrix() it means errors were found. We output the returned 'error' strings
		if(!is_array($mergedMatrix)) {
			$this->error($mergedMatrix, Notice::allowMarkup);
			return;

		}

		$pages = wire('pages');

		$tbody ='';//for matrix rows
		$thcols = '';//for matrix table column headers
		$rowHeaderLabel = $this->rowLabelFieldName;//this property was set in FieldtypeMatrix getInputfield()
		$columnHeaderLabel = $this->columnLabelFieldName;//this property was set in FieldtypeMatrix getInputfield()
		//@@todo - saved $columnHeaderLabler not being displayed as selected in Details tab! But value is correctly saved in db

		$i = 0;//set counter not to output extraneous column label headers
		//$j = 1;//counter for rows numbering
		$count = '';//initialise variable for counting number of columns
		
		foreach($mergedMatrix as $row => $cols) {

				//matrix table row headers (first column)
				$rh = $pages->get($row);//getting by page->id
				#$tbody .= "<tr><td><strong>" . $pages->get($row)->title . "</strong></td>";

				//if we have a row label from selected field show it otherwise show title
				$rowLabel = $rh->$rowHeaderLabel ? $rh->$rowHeaderLabel : $rh->title;
				/*$tbody .= "<tr>
								<td class=MatrixRowCount>" . $j. "</td>
	            				<td>" . $rowLabel. "</td>";*///@@left here in case will switch to row counters in the future

				$tbody .= "<tr><td class='MatrixRowHeader'>" . $rowLabel . "</td>";

				//we count this once only rather than on each 'row' loop!
				if($i == 0) $count = count($cols);//help to stop output of extra/duplicate column headers

				foreach($cols as $col => $value) {

							//matrix table column headers
							$ch = $pages->get($col);//getting by page->id

							//if we have a column label from selected field show it otherwise show title
							$columnLabel = $ch->$columnHeaderLabel ? $ch->$columnHeaderLabel : $ch->title;

							//avoid outputting extra duplicate columns. 
							if($i < $count) {

									$thcols .= "<th class='MatrixColumnHeader'>" . $columnLabel  . "</th>";

									$i++;//no need to keep incrementing after number of desired columns reached

							}

							//input name will be in the format 'R5282_C5289' to match row and column page IDs respectively
							#$tbody .= "<td><input type='text' name='matrix[R" . $rh->id . "_C" . $ch->id . "]' value='" . $value . "'></td>";
							$tbody .= "<td><input type='text' name='matrix_" . $this->field->name. "[R" . $rh->id . "_C" . $ch->id . "]' value='" . $value . "'></td>";	

				}

				$tbody .= "</tr>";

				//$j++;
		}

		//final matrix table for output
		 $out =   "<table class='InputfieldMatrix'>
						<thead>
							<tr class=''>
								<th></th>
									$thcols
							</tr>
						</thead>
						<tbody>
							$tbody
						</tbody>
					</table>";

		//paste CSV data options
		$inputfields = new InputfieldWrapper();

		$fieldset = $this->modules->get('InputfieldFieldset'); 
		$fieldset->attr('id', 'csv_import'); 
		$fieldset->label = "CSV Data";
		$fieldset->description = $this->_('If you prefer, you may paste in CSV data below rather than entering them manually to populate your matrix table above.');
		$fieldset->collapsed = Inputfield::collapsedYes;

		//csv delimeter
		$f = $this->modules->get('InputfieldText');
		$f->name = 'csv_column_separator';
		$f->label = $this->_('Columns delimited by');
		$f->notes = $this->_('For tab-separated, enter: tab.');
		$f->value = ',';
		#$f->columnWidth = 50;
		$fieldset->add($f);

		//csv enclosure
		$f = $this->modules->get('InputfieldText');
		$f->name = 'csv_column_enclosure';
		$f->label = $this->_('Column enclosure');
		$f->notes = $this->_('When a value contains a delimeter, it must be enclosed by a character (typically a double quote character). If you are not sure what should go here, it is recommended you leave it at the default (").');
		$f->value = '"';
		if($f->value == '"') $f->collapsed = Inputfield::collapsedYes;
		$f->attr('maxlength', 1); 
		$f->attr('size', 1); 
		#$f->columnWidth = 50;

		$fieldset->add($f);

		//csv paste
		$f = $this->modules->get('InputfieldTextarea');
		$f->name = "matrix_" . $this->field->name . "_csvdata";
		$f->label = $this->_('Paste in CSV Data');
		$f->description = $this->_('If you prefer, you may paste in CSV data here rather than entering them manually to populate your matrix table above. 
			Values entered here overwrite those in the matrix table!');
		$f->notes = $this->_('1. If you wish to import values for your whole matrix table, be sure that the number of rows and columns in your CSV data exactly match the matrix table above.
			2. Any extra rows/columns will be discarded. 
			3. However, you can also paste in CSV data with less rows/columns or with some missing values. 
			4. After saving, you will be able to manually input missing values and/or correct mistakes. 
			5. The CSV Data must not contain header rows.');

		$fieldset->add($f);

		$inputfields->add($fieldset);

		return $out . $inputfields->render();
	}
	
	
	/**
	 * Process input for the values sent from the Matrix table for this page
	 *
	 */
	public function ___processInput(WireInputData $input) {

		if(!$this->page || !$this->field) {
			throw new WireException("This inputfield requires that you set valid 'page' and 'field' properties to it."); 
		}

		$name = 'matrix_' . $this->attr('name');

		//dealing with manually entered values
		if ($input->{"{$name}_csvdata"} == '') {

					$matrices = $this->field->type->getBlankValue($this->page, $this->field);

					$count = 0;//counter for values saved
					
					foreach($input->{"{$name}"} as $key => $value) {
							
							//if value empty, we skip the record; no need to save empty values!
							if($value == '') continue;

							//$key is in the format R1234_C1234 reflecting row and column pages' IDs respectively
							$rowCol = explode('_', $key);//[0]=>R1234, [1]=>C1234

							$row = str_replace('R', NULL, $rowCol[0]);//clean row page ID
							$column = str_replace('C', NULL, $rowCol[1]);//clean column page ID

							//create a new matrix and add it to our matrices
							$m = new Matrix();

							$m->matrix_row = (int) $row;//@@todo - don't really need to sanitize here as well since done in Matrix::set() too?
							$m->matrix_column = (int) $column;//@@todo - ditto
							$m->matrix_value = $value;

							$matrices->add($m);//add matrix to MatrixArray

							$count++;

					}//end foreach

					$this->message(sprintf(_n("Saved %d matrix value.", "Saved %d matrix values.", $count), $count));//tell user how many values were saved

		}

		//dealing with csv values
		else {

					$csvRawData = $input->{"{$name}_csvdata"};
					$csvDelimiter = $input->csv_column_separator;
					$csvEnclosure = $input->csv_column_enclosure;

					$matrices = $this->prepareCSV($csvRawData, $csvDelimiter, $csvEnclosure);

		}
	
		//if the string values of the processed matrices are different from the previous,
		//or if any matrices have been deleted, then flag this Inputfield as changed
		//so that it will be automatically saved with the page
		
		//if things have changed, we take the new values
		if("$matrices" != "$this->value") {
			
				$this->attr('value', $matrices); 
				$this->trackChange('value'); 
		}
		

	}

	/**
	 * Prepare copy-pasted CSV matrix values for processing
	 * These will either be processed using MatrixArray/Matrix or MySQL LOAD DATA INFILE
	 */
	public function prepareCSV($csvRawData, $csvDelimiter, $csvEnclosure) {

		//prepare some variables
		$pages = wire('pages');
		$page = $this->page;
		$rowsParent = '';
		$columnsParent = '';
		
		$parentRowColumnSelector = $this->parentRowColumnFieldName;//this property was set in FieldtypeMatrix getInputfield()
		$rowSelector = $this->rowSelector;//this property was set in FieldtypeMatrix getInputfield()
		$columnSelector = $this->columnSelector;//this property was set in FieldtypeMatrix getInputfield()

		//if Page Field specified, we use that to find the children pages of the specified row and column parent pages respectively (this will match what is already in the matrix table)
		if($parentRowColumnSelector) {

				//rows parent
				$rowsParent = $page->$parentRowColumnSelector->first();//the first selected page is treated as the row pages parent
		
				//columns parent
				$columnsParent = $page->$parentRowColumnSelector->getNext($rowsParent);//the second selected page is treated as the column pages parent
		
				//find all matrix-row pages
				$rowPages = $rowsParent->children;

				//find all matrix-column pages
				$columnPages = $columnsParent->children;

		}

		//if Page Field NOT specified, we use specified row/column selectors instead
		else {

				//find all matrix-row pages
				$rowPages = $pages->find($rowSelector);//ProcessWire will throw an exception here if the selector is not valid

				//find all matrix-column pages
				$columnPages = $pages->find($columnSelector);//ProcessWire will throw an exception here if the selector is not valid

		}

		foreach ($rowPages as $row) $rows[] = $row->id;
		$cntRows = count($rows);

		foreach ($columnPages as $col) $columns[] = $col->id;
		$cntCols = count($columns);

		//if no $csvDelimiter set, throw error, return! rather than assume default ',' [comma]
		if(!$csvDelimiter) {
				$this->error($this->_('A CSV delimiter has to be set!'));
				return;
		}

		$data = array();
		$i = 0;//rows counter
		$j = 0;//columns counter

		//loop through the raw csv values line by line prepping our CSV values for later processing
		foreach(explode("\n", $csvRawData) as $row){

				//convert csv string
				$csvData = str_getcsv($row, $csvDelimiter == "tab" ? chr(9) : $csvDelimiter, $csvEnclosure);//check delimiter type here
				//chr(9) is ASCII standard character for TAB	        
		        
		        foreach ($columns as $col) {

						//if value not set OR if value set but empty, we skip it and the related column and move to the next column
						if( (!isset($csvData[$j])) || (isset($csvData[$j]) && !strlen(str_replace(' ', '', $csvData[$j]))) ) {
								$j++;
								continue;
						}

						/*					
						save row->id, col->id and csv value in the format 

							array (

										[0] =>	array (

														[0] => row->id
														[1] => col-id
														[2] => value
										)

							)

						*/
						
						//we'll use this array to write to a csv file to read through using LOAD DATA INFILE
						//we need this step since our $csvRawData is in a matrix table format
						// there'll be now way to flip it using LOAD DATA INFILE to correctly insert the row,column,value data in the db
						$data[] = array((int)$rows[$i], (int)$col , $this->sanitizer->text($csvData[$j]));
						$j++;
						if($j == $cntCols) break;//if csv data columns exceed columns in matrix table we abort
				}

				$i++;
				$j=0;//reset the column counter for next loop
				if($i == $cntRows) break;//if csv data rows exceed rows in matrix table we abort
		
		}//end foreach explode $csvRawData

		//if use chose to use LOAD DATA INFILE (this property was set in FieldtypeMatrix getInputfield())
		if ($this->loadDataInfile) {

				$this->processCSVLoadDataInfile($data, $csvDelimiter, $csvEnclosure);
				return;//back to base after processing
		}

		else {

				return $this->processCSVMatrix($data);//this will return $matrices

		}
		

	}

	/**
	 * Process copy-pasted CSV matrix values using MatrixArray/Matrix method
	 *
	 */
	public function processCSVMatrix($data) {

		$matrices = $this->field->type->getBlankValue($this->page, $this->field);

		$count = 0;//counter for values saved

		//loop through the sanitized csv data. Empty values have already been removed in prepareCSV()
		foreach ($data as $d) {
		  
				#our row $page->id is at index[0] in the inner array $d
				#our column $page->id is at index[1] in the inner array $d
				#our matrix intersection/cell is the $value and it is at index[2]

					//create a new matrix and add it to our matrices
					$m = new Matrix();

					//these were already sanitized in prepareCSV() [and will be again in Matrix::set()]
					$m->matrix_row		= 	$d[0];//row page->id
					$m->matrix_column 	= 	$d[1];//column page->id
					$m->matrix_value 	= 	$d[2];//csv value

					$matrices->add($m);//add matrix to MatrixArray

					$count++;

		}//end foreach $data as $d

		$this->message(sprintf(_n("Saved %d matrix value.", "Saved %d matrix values.", $count), $count));//tell user how many values were saved
		
		return $matrices;//return the matrices object

	}

	/**
	 * Process copy-pasted CSV matrix values
	 *
	 */
	public function processCSVLoadDataInfile($data, $csvDelimiter, $csvEnclosure) {

		//prepare some variables
		$page = $this->page;

		$csvFilename = $page->filesManager()->path() . 'data.csv'; //this pages /assets/files/ folder

		//force create and write to a temp 'data.csv' file. we'll delete it later
		$handle = fopen($csvFilename, 'w+');

		foreach ($data as $line) fputcsv($handle, $line, $csvDelimiter, $csvEnclosure);//write csv values to data.csv

		fclose($handle);//closee the resource stream

		//$database is the ProcessWire PDO way.
		$database = $this->wire('database');
		$table = $database->escapeTable($this->field->table);//see /wire/core/Fieldtype.php. returns 'field_name_of_field' (i.e. as in the database)

		//we need to delete this page's older db values
		$sql = "DELETE FROM `$table` WHERE pages_id=:page_id";//need backticks around $table
		
		$query = $database->prepare($sql);//prepare delete statement
		$query->bindValue(":page_id", $page->id, PDO::PARAM_INT);//bind our named parameter
		$query->execute();//delete values

		//LOAD DATA INFILE statement
		//In Multipage-like fields, ProcessWire uses a Composite PRIMARY KEY made up of 'pages_id' and 'sort'
		//Since there can be multiple identical 'pages_id', 'sort' has to be unique always
		//We start sort from 0 and increment this for each db record
		$sql = "				
				SET @i:=-1;
				LOAD DATA INFILE :csvFilename
				INTO table `$table`
				FIELDS TERMINATED BY :csvDelimiter
				OPTIONALLY ENCLOSED BY :csvEnclosure
				LINES TERMINATED BY '\\n'
				(data, matrix_column, matrix_value)
				SET 
					pages_id =:page_id,
					sort = @i:=@i+1;
		
		";

		$query = $database->prepare($sql);//prepare LOAD DATA INFILE statement
		$query->bindValue(":csvFilename", $csvFilename);//bind our named parameters
		$query->bindValue(":csvDelimiter", $csvDelimiter);
		$query->bindValue(":csvEnclosure", $csvEnclosure);
		$query->bindValue(":page_id", $page->id, PDO::PARAM_INT);
		$query->execute();//let's write some data

		$sql = "SELECT COUNT(*) FROM `$table` WHERE pages_id=:page_id";

		$query = $database->prepare($sql);//prepare count number of newly written values
		$query->bindValue(":page_id", $page->id, PDO::PARAM_INT);//bind our named parameter
		$query->execute();//execute our count

		$count = $query->fetchColumn();//fetch the count

		if(is_file($csvFilename)) unlink($csvFilename);//delete the data.csv file we created earlier

		$this->message(sprintf(_n("Saved %d matrix value.", "Saved %d matrix values.", $count), $count));//tell user how many values were saved

	}


}

