<?php

/**
* InputfieldMatrix for ProcessWire.
*
* This Inputfield is a GUI for FieldtypeMatrix.
*
* @author Kongondo <kongondo@gmail.com>
* @author Ryan Cramer 
* 
* Largely based on original code from Ryan Cramer's FieldtypeEvnents. 
*
* Lincensed under GNU/GPL v2.
*
* https://github.com/kongondo/FieldtypeMatrix
* Created December 2014
* 
* ProcessWire 2.x
* Copyright (C) 2011 by Ryan Cramer
* Licensed under GNU/GPL v2, see LICENSE.TXT
*
* http://www.processwire.com
*
*/

class InputfieldMatrix extends Inputfield {

	public static function getModuleInfo() {
		return array(
			'title' => 'Matrix',
			'author' => 'Kongondo',
			'version' => 100,
			'href' => 'https://processwire.com/talk/topic/8581-module-matrix-fieldtype-inputfield/',
			'summary' => 'Inputfield for a 2D-matrix.',
			'requires' => 'FieldtypeMatrix', 
			);
	}

	protected $page;
	protected $field;

	public function setPage(Page $page) {
		
		$this->page = $page; 
	}

	public function setField(Field $field) {

		$this->field = $field;
	}	

	/**
	 * Build an array for outputting a Matrix Table/Grid
	 *
	 */
	public function mergeMatrix() {

		//prepare some variables
		$values = $this->attr('value');
		$pages = wire('pages');
		$page = $this->page;
		$rowsParent = '';
		$columnsParent = '';
		
		$parentRowColumnSelector = $this->parentRowColumnFieldName;//this property was set in FieldtypeMatrix getInputfield()
		$rowSelector = $this->rowSelector;//this property was set in FieldtypeMatrix getInputfield()
		$columnSelector = $this->columnSelector;//this property was set in FieldtypeMatrix getInputfield()
		
		$editURL = $this->wire('config')->urls->admin . 'setup/field/edit?id=' . $this->field->id;
		
		### first we deal with errors. We'll return these as strings to oupput in $this->error() in render() ###

		//in neither a Page Field nor selectors for finding pages to build matrix rows/columns specified set error message
		if((!$parentRowColumnSelector) && (!$rowSelector || !$columnSelector))
				return '<a href="' . $editURL .'">' . 	$this->_('Check the Details Tab of the field') . '</a> ' . $this->field->name . 
														$this->_('. You need to either use selectors or a Page Field to find pages to show in your matrix table.');

		//if Page Field specified, we use that to find the children pages of the specified row and column parent pages respectively
		if($parentRowColumnSelector) {
				//if the page field does not return a PageArray, set error message	
				if(!$page->$parentRowColumnSelector instanceof PageArray)
					return '<a href="' . $editURL .'">' . 	$this->_('Check the Details Tab of the field') . '</a> ' . $this->field->name . 
															$this->_('. Only a Page Field can be used to specify the rows and columns parent pages for building your matrix! Confirm that you specified a Multiplepage Field.');

				//if less than 2 matrix parent pages selected (we need one for rows and the other for columns) set error message
				if(count($page->$parentRowColumnSelector) < 2) return $this->_('You need to select 1 matrix rows parent and 1 matrix columns parent.');

				### rows parent ###
				$rowsParent = $page->$parentRowColumnSelector->first();//the first selected page is treated as the row pages parent
				
				//if for some reason specified $rowsParent does not exist set error message
				if(!$rowsParent) return $this->_('The specified matrix row parent page was not found. Confirm it exists or specify another.');
				
				//if $rowsParent does not have children set error message
				if(!$rowsParent->numChildren) return $this->_('The specified matrix rows parent does not have children. You need to first create its child pages.');

				#### columns parent ####
				$columnsParent = $page->$parentRowColumnSelector->getNext($rowsParent);//the second selected page is treated as the column pages parent

				//if for some reason specified $columnsParent does not exist set error message
				if(!$columnsParent) return $this->_('The specified matrix columns parent page was not found. Confirm it exists or specify another.');
				
				//if $columnsParent does not have children set error message
				if(!$columnsParent->numChildren) return $this->_('The specified matrix column parent does not have children. You need to first create its child pages.');
				
				##### -if we made it here, we are good to go ####
				//find all matrix-row pages
				$rows = $rowsParent->children;

				//find all matrix-column pages
				$columns = $columnsParent->children;
	
		}//end if a Page Field was specified

		//if Page Field NOT specified, we use specified row/column selectors instead
		else {

				//find all matrix-row pages
				$rows = $pages->find($rowSelector);//ProcessWire will throw an exception here if the selector is not valid

				//find all matrix-column pages
				$columns = $pages->find($columnSelector);//ProcessWire will throw an exception here if the selector is not valid

				//if row/column selectors return empty set error message
				if(!count($rows)) 
					return 	$this->_('No row pages found with the selector set in \'Row Matrix pages\' for the field ') . $this->field->name . 
							'. <a href="' . $editURL .'">' . 	$this->_('Amend your selector') . '</a>.';
				
				if(!count($columns)) 
					return 	$this->_('No column pages found with the selector set in \'Column Matrix pages\' for the field ') . $this->field->name . 
							'. <a href="' . $editURL .'">' . 	$this->_('Amend your selector') . '</a>.';

		}//end else we use row/column selectors

		//create our default matrix with blank values (i.e. blank matrix->value)
		//we later merge this with saved values in the db
		//this will help us detect if new row/column pages have been added
		$defaultMatrix = array();

		//get the rows and columns to build our empty-values default matrix
		foreach($rows as $row) {

				//create our rows - top level array
				#$defaultMatrix[$row->id] = '';//no need for this here

				//create our columns - 2nd level array WITH empty values
				foreach($columns as $column) {
							
							$defaultMatrix[$row->id][$column->id] = '';//value = blank
				}

		}

		//get our saved db matrix values
		$dbMatrix = array();//for storing row/column values already saved in db

		//loop through saved db vakues
		foreach($values as $m) {

				//get the row page
				$rp = $pages->get($m->row);
				
				//in case the matrix rows parent was changed and is different from the rows parent of the saved db values...
				//we skip such rows in readiness for deletion
				//we only do this if a Page Field was used to select matrix rows (difficult if a selector was used - no problem since assuming only supersuser can edit selector in Page Field)
				if($rowsParent && $rp->parent != $rowsParent) continue;

				//remove matrix-rows that are no longer needed i.e. 'unpublished', 'hidden', 'deleted' or 'trashed'
				if(!$rp || $rp->is(Page::statusUnpublished) || $rp->isHidden() || $rp->isTrash()) continue;
				//if(!$rp || $rp->is('unpublished') || $rp->is('hidden')) continue;//syntax will only work in PW 2.5+ ?

				//build the saved values array
				#$dbMatrix[$m->row][$m->column] = $m->value;//
				$dbMatrix[$m->row][$m->column] = $this->sanitizer->entities($m->value);//@@todo - need to sanitize this values for display?

				//get the column page
				$cp = $pages->get($m->column);

				//remove matrix-columns that are no longer needed i.e. 'unpublished', 'hidden', 'deleted' or 'trashed'
				if(!$cp || $cp->is(Page::statusUnpublished) || $cp->isHidden() || $cp->isTrash()) unset($dbMatrix[$m->row][$m->column]);
				
				//in case the matrix columns parent was changed and is different from the columns parent of the saved db values...
				//we remove such columns in readiness for deletion
				//we only do this if a Page Field was used to select matrix columns (ditto above)
				if($columnsParent && $cp->parent != $columnsParent) unset($dbMatrix[$m->row][$m->column]);

		}

		//prepare our final matrix to output to page (edit) InputfieldMatrix
		//we recursively replace defaultMatrix blank values with dbMatrix values where applicable (matched array keys)
		//'new' (i.e. not in $dbMatrix) default row/column combinations are preserved and added to final matrix
		//note: values previously saved using a different selector will still be present!...
		//as long as their respective pages have not been deleted/trashed/hid/unpublished
		$mergedMatrix = array_replace_recursive($defaultMatrix, $dbMatrix);

		return $mergedMatrix;//matrix array

	}

	/**
	 * Render the entire input area for a Matrix
	 *
	 */
	public function ___render() {

		//#########	CREATE MATRIX TABLE #########

		$mergedMatrix = $this->mergeMatrix();

		//if we didn't get an array back from $mergeMatrix() it means errors were found. We output the returned 'error' strings
		if(!is_array($mergedMatrix)) {
			$this->error($mergedMatrix, Notice::allowMarkup);
			return;

		}

		$pages = wire('pages');

		$tbody ='';//for matrix rows
		$thcols = '';//for matrix table column headers
		$rowHeaderLabel = $this->rowLabelFieldName;//this property was set in FieldtypeMatrix getInputfield()
		$columnHeaderLabel = $this->columnLabelFieldName;//this property was set in FieldtypeMatrix getInputfield()

		$i = 0;//set counter not to output extraneous column label headers
		//$j = 1;//counter for rows numbering
		$count = '';//initialise variable for counting number of columns
		
		foreach($mergedMatrix as $row => $cols) {

				//matrix table row headers (first column)
				$rh = $pages->get($row);//getting by page->id
				#$tbody .= "<tr><td><strong>" . $pages->get($row)->title . "</strong></td>";

				//if we have a row label from selected field show it otherwise show title
				$rowLabel = $rh->$rowHeaderLabel ? $rh->$rowHeaderLabel : $rh->title;
				/*$tbody .= "<tr>
								<td class=MatrixRowCount>" . $j. "</td>
	            				<td>" . $rowLabel. "</td>";*///@@left here in case will switch to row counters in the future

				$tbody .= "<tr><td class='MatrixRowHeader'>" . $rowLabel . "</td>";

				//we count this once only rather than on each 'row' loop!
				if($i == 0) $count = count($cols);//help to stop output of extra/duplicate column headers

				foreach($cols as $col => $value) {

							//matrix table column headers
							$ch = $pages->get($col);//getting by page->id

							//if we have a column label from selected field show it otherwise show title
							$columnLabel = $ch->$columnHeaderLabel ? $ch->$columnHeaderLabel : $ch->title;

							//avoid outputting extra duplicate columns. 
							if($i < $count) {

									$thcols .= "<th class='MatrixColumnHeader'>" . $columnLabel  . "</th>";

									$i++;//no need to keep incrementing after number of desired columns reached

							}

							//input name will be in the format 'R5282_C5289' to match row and column page IDs respectively
							#$tbody .= "<td><input type='text' name='matrix[R" . $rh->id . "_C" . $ch->id . "]' value='" . $value . "'></td>";
							$tbody .= "<td><input type='text' name='matrix_" . $this->field->name. "[R" . $rh->id . "_C" . $ch->id . "]' value='" . $value . "'></td>";

				}

				$tbody .= "</tr>";

				//$j++;
		}

		//button to reset/clear all matrix values before save

		$clearAllButton = "<input type='button' class='InputfieldMatrixReset' value='Reset' />";

		//final matrix table for output
		$out =   "
					$clearAllButton
		 			<table class='InputfieldMatrix'>
						<thead>
							<tr class=''>
								<th></th>
									$thcols
							</tr>
						</thead>
						<tbody>
							$tbody
						</tbody>
					</table>					
					$clearAllButton
		";

		//paste CSV data options
		$inputfields = new InputfieldWrapper();

		$fieldset = $this->modules->get('InputfieldFieldset');
		$fieldset->attr('id', 'csv_import'); 
		$fieldset->label = $this->_('Upload/Paste CSV Data');
		$fieldset->description = $this->_('If you prefer, you may upload a CSV file or copy-paste CSV data here rather than manually entering values in your matrix table above.');
		$fieldset->collapsed = Inputfield::collapsedYes;

		//upload csv/txt file
		$f = $this->modules->get("InputfieldMarkup");
		$f->label = $this->_('CSV File');
		$f->value = "<input name='matrix_" . $this->field->name . "_csvfile' type='file' />";
		$f->description = 
			 $this->_("UTF-8 compatible encoding is assumed. The file must have the extension '.csv' or '.txt'. You can also copy-paste in CSV data in the 'Paste in CSV Data' section below. You may do one or the other, but not both simultaneously. If you did both, copy-pasted values would be disregarded. If your CSV data is not comma-delimeted, specify your delimiter below before proceeding.");
		$f->notes = $this->_("1. If you wish to import values for your whole matrix table, be sure that the number of rows and columns in your CSV data exactly match the matrix table above.\n") . 
			$this->_("2. Any extra rows/columns will be discarded.\n") . 
			$this->_("3. However, your CSV data can also have less rows/columns or some missing values.\n") .  
			$this->_("4. After saving, you will be able to manually input missing values and/or correct mistakes.\n") . 
			$this->_("5. The CSV Data must not contain a column/header row, i.e. the first row in your CSV values will be saved as data.");

		$fieldset->add($f);

		//csv delimeter
		$f = $this->modules->get('InputfieldText');
		$f->name = 'csv_column_separator';
		$f->label = $this->_('Columns delimited by');
		$f->notes = $this->_('For tab-separated, enter: tab.');
		$f->value = ',';
		
		$fieldset->add($f);

		//csv enclosure
		$f = $this->modules->get('InputfieldText');
		$f->name = 'csv_column_enclosure';
		$f->label = $this->_('Column enclosure');
		$f->notes = $this->_('When a value contains a delimeter, it must be enclosed by a character (typically a double quote character). If you are not sure what should go here, it is recommended you leave it at the default (").');
		$f->value = '"';
		if($f->value == '"') $f->collapsed = Inputfield::collapsedYes;
		$f->attr('maxlength', 1);
		$f->attr('size', 1);

		$fieldset->add($f);

		//csv paste
		$f = $this->modules->get('InputfieldTextarea');
		$f->name = "matrix_" . $this->field->name . "_csvpasted";
		$f->label = $this->_('Paste in CSV Data');
		$f->description = $this->_('Values entered here overwrite those in the matrix table!');
		$f->notes = $this->_("The notes outlined above in 'CSV File' are applicable here.");
		$f->collapsed = Inputfield::collapsedYes;

		$fieldset->add($f);

		$inputfields->add($fieldset);

		return $out . $inputfields->render();
	}
	
	
	/**
	 * Process input for the values sent from the Matrix table for this page
	 *
	 */
	public function ___processInput(WireInputData $input) {

		if(!$this->page || !$this->field) {
			throw new WireException("This inputfield requires that you set valid 'page' and 'field' properties to it."); 
		}

		$name = 'matrix_' . $this->attr('name');

		$csvFilename = $_FILES["{$name}_csvfile"]["name"];
		$csvPasted = $input->{"{$name}_csvpasted"};
		$csvDelimiter = $input->csv_column_separator;
		$csvEnclosure = $input->csv_column_enclosure;

		//dealing with uploaded csv/txt file
		if($csvFilename !='') {

				//WireUpload stuff
				$validExts = array('txt', 'csv');//allow only .csv and .txt files

				$csvFileProcess = new WireUpload("{$name}_csvfile");//name of csv file upload <input>
				$csvFileProcess->setOverwrite(true);//overwrite files
				$csvFileProcess->setMaxFiles(1);//only allow one file!
				$csvFileProcess->setDestinationPath($this->page->filesManager()->path());//temporarily upload to current page's /assets/files/
				$csvFileProcess->setValidExtensions($validExts);//check for valid file extensions

				//upload the csv/txt file
				$file = $csvFileProcess->execute();
				
				//if no valid file found, show error message and abort
				if(!count($file)) {
								$this->error($this->_('You need to upload file with a valid extension!'));
								return false;
				}
				
				$csvTempFileName = 'matrix-temp-data.csv';
				$csvFilePath = $this->page->filesManager()->path;
				
				//rename the file including its extension
				$csvRenameFile = rename($csvFilePath . $csvFilename, $csvFilePath . $csvTempFileName);//returns true on success
				
				//if file successfully renamed
				if($csvRenameFile) $csvRawData = $this->page->filesManager()->path . $csvTempFileName;//full path to our temp csv file

				//first just double checking we got the renamed file. we pass this to prepareCSV()
				if(is_file($csvRawData)) {
							$matrices = $this->prepareCSV($csvRawData, $csvDelimiter, $csvEnclosure);
				}

				else {
								$this->error($this->_('We did not find a valid file! Please retry.'));
								return false;
				}

		}

		//dealing with copy-pasted csv values
		elseif($csvPasted !='') {

					$csvRawData = $csvPasted;
					$matrices = $this->prepareCSV($csvRawData, $csvDelimiter, $csvEnclosure);

		}

		//if no file or no copy-pasted values, we are dealing with manually entered matrix values (i.e. none-CSV data)
		else {

					$matrices = $this->field->type->getBlankValue($this->page, $this->field);

					$count = 0;//counter for values saved
					
					foreach($input->{"{$name}"} as $key => $value) {
							
							//if value empty, we skip the record; no need to save empty values!
							if($value == '') continue;

							//$key is in the format R1234_C1234 reflecting row and column pages' IDs respectively
							$rowCol = explode('_', $key);//[0]=>R1234, [1]=>C1234

							$row = str_replace('R', NULL, $rowCol[0]);//clean row page ID
							$column = str_replace('C', NULL, $rowCol[1]);//clean column page ID

							//create a new matrix and add it to our matrices
							$m = new Matrix();

							$m->row = (int) $row;//@@todo - don't really need to sanitize here as well since done in Matrix::set() too?
							$m->column = (int) $column;//@@todo - ditto
							$m->value = $value;

							$matrices->add($m);//add matrix to MatrixArray

							$count++;

					}//end foreach

					//tell user how many values were saved
					$this->message(sprintf(_n("Saved %d matrix value.", "Saved %d matrix values.", $count), $count));

		}
	
		//if the string values of the processed matrices are different from the previous,
		//or if any matrices have been deleted, then flag this Inputfield as changed
		//so that it will be automatically saved with the page
		
		//if things have changed, we take the new values
		if("$matrices" != "$this->value") {
			
				$this->attr('value', $matrices);
				$this->trackChange('value'); 
		}
		

	}

	/**
	 * Prepare copy-pasted CSV matrix values for processing
	 * These will either be processed using MatrixArray/Matrix or MySQL LOAD DATA INFILE
	 */
	public function prepareCSV($csvRawData, $csvDelimiter, $csvEnclosure) {

		//prepare some variables
		$pages = wire('pages');
		$page = $this->page;
		$rowsParent = '';
		$columnsParent = '';
		
		$parentRowColumnSelector = $this->parentRowColumnFieldName;//this property was set in FieldtypeMatrix getInputfield()
		$rowSelector = $this->rowSelector;//this property was set in FieldtypeMatrix getInputfield()
		$columnSelector = $this->columnSelector;//this property was set in FieldtypeMatrix getInputfield()

		//if Page Field specified, we use that to find the children pages of the specified row and column parent pages respectively (this will match what is already in the matrix table)
		if($parentRowColumnSelector) {

				//rows parent
				$rowsParent = $page->$parentRowColumnSelector->first();//the first selected page is treated as the row pages parent
		
				//columns parent
				$columnsParent = $page->$parentRowColumnSelector->getNext($rowsParent);//the second selected page is treated as the column pages parent
		
				//find all matrix-row pages
				$rowPages = $rowsParent->children;

				//find all matrix-column pages
				$columnPages = $columnsParent->children;

		}

		//if Page Field NOT specified, we use specified row/column selectors instead
		else {

				//find all matrix-row pages
				$rowPages = $pages->find($rowSelector);//ProcessWire will throw an exception here if the selector is not valid

				//find all matrix-column pages
				$columnPages = $pages->find($columnSelector);//ProcessWire will throw an exception here if the selector is not valid

		}

		foreach ($rowPages as $row) $rows[] = $row->id;
		$cntRows = count($rows);

		foreach ($columnPages as $col) $columns[] = $col->id;
		$cntCols = count($columns);

		//if no $csvDelimiter set, throw error, return! rather than assume default ',' [comma]
		if(!$csvDelimiter) {
				$this->error($this->_('A CSV delimiter has to be set!'));
				return;
		}

		$data = array();
		$i = 0;//rows counter
		$j = 0;//columns counter

		/*					
		#### creating an array mirroring our db structure ###
		save row->id, col->id, csv value as below:

			array (

						[0] =>	array (

										[0] => row->id
										[1] => col-id
										[2] => value
						)

			)

		*/
		
		/*
			++ if uploading/copy-pasting csv data, we'll use this array in one of two ways: ++

			(1) if using LOAD DATA INFILE:				
				- we need this step since our $csvRawData is in a matrix table format
				- there'll be no way to flip the values using LOAD DATA INFILE to correctly insert the row,column,value data in the db
				- So, we have to do it this way
		
			(2) if saving csv values using 'normal' MatrixArray/Matrix method
				- we'll later use the array with new Matrix() to save values to db
		*/

		//if csv file uploaded [matrix-temp-data.csv]
		if(is_file($csvRawData)) {

				$csvFilename = $csvRawData;

				//deal with Mac line endings
				ini_set('auto_detect_line_endings', true);
				
				//open our csv file as read-only
				$handle = fopen($csvFilename, "r");

				//convert csv string to array
				//we also check delimiter type here - chr(9) is ASCII standard character for TAB
				while(($csvData = fgetcsv($handle, 0, $csvDelimiter == "tab" ? chr(9) : $csvDelimiter, $csvEnclosure)) !== false) {
					$cnt = count($data);
		
					foreach ($columns as $col) {

							//if value not set OR if value set but empty, we skip it and the related column and move to the next column
							//note, however, that we are not skipping blank lines wholesale as those may be intentional!
							if( (!isset($csvData[$j])) || (isset($csvData[$j]) && !strlen(str_replace(' ', '', $csvData[$j]))) ) {
									$j++;
									continue;
							}

							//first, attempt to auto-detect char encoding of 'troublesome' characters
							//then encode to UTF-8
							$value = $this->charEncode($csvData[$j], 'UTF-8');

							$data[] = array((int)$rows[$i], (int)$col , $this->sanitizer->text($value));
							#$data[] = array( (int)$rows[$i], (int)$col , $this->sanitizer->text($csvData[$j]));
							
							$j++;
							if($j == $cntCols) break;//if csv data columns exceed columns in matrix table we abort
					
					}//end foreach $columns as $col

					$i++;
					$j=0;//reset the column counter for next loop
					if($i == $cntRows) break;//if csv data rows exceed rows in matrix table we abort

				}//end while $data...

				fclose($handle);//close the resource stream
				ini_set('auto_detect_line_endings', false);//close auto detect line endings
				
				if(is_file($csvRawData)) unlink($csvRawData);//delete 'matrix-temp-data.csv'

		}

		//else copy-pasted csv
		else {

				//loop through the raw csv values line by line prepping our CSV values for later processing
				foreach(explode("\n", $csvRawData) as $row){

						//convert csv string to array
						//we also check delimiter type here - chr(9) is ASCII standard character for TAB
						$csvData = str_getcsv($row, $csvDelimiter == "tab" ? chr(9) : $csvDelimiter, $csvEnclosure);	        
				        
						foreach ($columns as $col) {

								//if value not set OR if value set but empty, we skip it and the related column and move to the next column
								if( (!isset($csvData[$j])) || (isset($csvData[$j]) && !strlen(str_replace(' ', '', $csvData[$j]))) ) {
										$j++;
										continue;
								}

								$data[] = array((int)$rows[$i], (int)$col , $this->sanitizer->text($csvData[$j]));
								$j++;
								if($j == $cntCols) break;//if csv data columns exceed columns in matrix table we abort

						}//end foreach $columns as $col

						$i++;
						$j=0;//reset the column counter for next loop
						if($i == $cntRows) break;//if csv data rows exceed rows in matrix table we abort
				
				}//end foreach explode $csvRawData


		}//end else copy-pasted csv
		
		//if user chose to use LOAD DATA INFILE (this property was set in FieldtypeMatrix getInputfield())
		if ($this->loadDataInfile) {

				$this->processCSVLoadDataInfile($data, $csvDelimiter == "tab" ? chr(9) : $csvDelimiter, $csvEnclosure);
				return;//back to base after processing
		}

		else {

				return $this->processCSVMatrix($data);//this will return $matrices

		}
		

	}

	/**
	 * Process copy-pasted CSV matrix values using MatrixArray/Matrix method
	 *
	 */
	public function processCSVMatrix($data) {

		$matrices = $this->field->type->getBlankValue($this->page, $this->field);

		$count = 0;//counter for number of values saved

		//loop through the sanitized csv data. Empty values have already been removed in prepareCSV()
		foreach ($data as $d) {
		  
				#our row $page->id is at index[0] in the inner array $d
				#our column $page->id is at index[1] in the inner array $d
				#our matrix intersection/cell is the $value and it is at index[2]

					//create a new matrix and add it to our matrices
					$m = new Matrix();

					//these were already sanitized in prepareCSV() [and will be again in Matrix::set()]
					$m->row		= 	$d[0];//row page->id
					$m->column 	= 	$d[1];//column page->id
					$m->value 	= 	$d[2];//csv value

					$matrices->add($m);//add matrix to MatrixArray

					$count++;

		}//end foreach $data as $d

		$this->message(sprintf(_n("Saved %d matrix value.", "Saved %d matrix values.", $count), $count));//tell user how many values were saved

		return $matrices;//return the matrices object

	}

	/**
	 * Process copy-pasted CSV matrix values
	 *
	 */
	public function processCSVLoadDataInfile($data, $csvDelimiter, $csvEnclosure) {

		//prepare some variables
		$page = $this->page;

		$csvFilename = $page->filesManager()->path() . 'matrix-data.csv'; //this pages /assets/files/ folder

		//deal with Mac line endings
		ini_set('auto_detect_line_endings', true);

		//force create and write to a temp 'matrix-data.csv' file. we'll delete it later
		$handle = fopen($csvFilename, 'w+');

		foreach ($data as $line) fputcsv($handle, $line, $csvDelimiter, $csvEnclosure);//write csv values to matrix-data.csv

		fclose($handle);//close the resource stream
		ini_set('auto_detect_line_endings', false);//close auto detect line endings

		//$database is the ProcessWire PDO way.
		$database = $this->wire('database');
		$table = $database->escapeTable($this->field->table);//see /wire/core/Fieldtype.php. returns 'field_name_of_field' (i.e. as in the database)

		//we need to delete this page's older db values
		$sql = "DELETE FROM `$table` WHERE pages_id=:page_id";//need backticks around $table
		
		$query = $database->prepare($sql);//prepare delete statement
		$query->bindValue(":page_id", $page->id, PDO::PARAM_INT);//bind our named parameter
		$query->execute();//delete values

		//LOAD DATA INFILE statement
		//In Multipage-like fields, ProcessWire uses a Composite PRIMARY KEY made up of 'pages_id' and 'sort'
		//Since there can be multiple identical 'pages_id', 'sort' has to be unique always
		//We start sort from 0 and increment this for each db record
		$sql = "				
				SET @i:=-1;
				LOAD DATA INFILE :csvFilename
				INTO table `$table`
				FIELDS TERMINATED BY :csvDelimiter
				OPTIONALLY ENCLOSED BY :csvEnclosure
				LINES TERMINATED BY '\\n'
				(data, matrix_column, matrix_value)
				SET 
					pages_id =:page_id,
					sort = @i:=@i+1;
		
		";

		$query = $database->prepare($sql);//prepare LOAD DATA INFILE statement
		$query->bindValue(":csvFilename", $csvFilename);//bind our named parameters
		$query->bindValue(":csvDelimiter", $csvDelimiter);
		$query->bindValue(":csvEnclosure", $csvEnclosure);
		$query->bindValue(":page_id", $page->id, PDO::PARAM_INT);
		$query->execute();//let's write some data

		$sql = "SELECT COUNT(*) FROM `$table` WHERE pages_id=:page_id";

		$query = $database->prepare($sql);//prepare count number of newly written values
		$query->bindValue(":page_id", $page->id, PDO::PARAM_INT);//bind our named parameter
		$query->execute();//execute our count

		$count = $query->fetchColumn();//fetch the count

		if(is_file($csvFilename)) unlink($csvFilename);//delete the matrix-data.csv file we created earlier for LOAD DATA INFILE

		$this->message(sprintf(_n("Saved %d matrix value.", "Saved %d matrix values.", $count), $count));//tell user how many values were saved

	}


	/**
	 * Attempt to auto-encode unrecognised characters during fopen operations.
	 * If detection fails, at least values are parsed without ??
	 *
	 * @author aaron@aarongough.com - php.net
	 */
	public function charEncode ($source, $targetEncoding) {
		
		//detect the character encoding of the incoming file
		$encoding = mb_detect_encoding($source, "auto");

		//escape all of the question marks so we can remove artifacts from
		//the unicode conversion process
		$target = str_replace( "?", "[question_mark]", $source );

		//convert the string to the target encoding
		$target = mb_convert_encoding( $target, $targetEncoding, $encoding);

		//remove any question marks that have been introduced because of illegal characters
		$target = str_replace( "?", "", $target );

		//replace the token string "[question_mark]" with the symbol "?"
		$target = str_replace( "[question_mark]", "?", $target );

		return $target;

	}



}

