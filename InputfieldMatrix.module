<?php

/**
* InputfieldMatrix for ProcessWire.
*
* This Inputfield is a GUI for FieldtypeMatrix.
*
* @author Kongondo <kongondo@gmail.com>
* @author Ryan Cramer 
* 
* Largely based on original code from Ryan Cramer's FieldtypeEvnents. 
*
* Lincensed under GNU/GPL v2.
*
* https://github.com/kongondo/FieldtypeMatrix
* Created December 2014
* 
* ProcessWire 2.x
* Copyright (C) 2011 by Ryan Cramer
* Licensed under GNU/GPL v2, see LICENSE.TXT
*
* http://www.processwire.com
*
*/

class InputfieldMatrix extends Inputfield {

	public static function getModuleInfo() {
		return array(
			'title' => 'Matrix',
			'author' => 'Kongondo',
			'version' => 6,
			'href' => 'https://processwire.com/talk/topic/8581-module-matrix-fieldtype-inputfield/',
			'summary' => 'Input field for a 2D-matrix.',
			'requires' => 'FieldtypeMatrix', 
			);
	}

	protected $page;
	protected $field;

	public function setPage(Page $page) {
		
		$this->page = $page; 
	}

	public function setField(Field $field) {

		$this->field = $field;
	}

	/**
	 * Build an array for outputting a Matrix Table/Grid
	 *
	 */

	public function mergeMatrix() {

		//prepare some variables
		$values = $this->attr('value');
		$pages = wire('pages');
		$page = $this->page;
		$rowsParent = '';
		$columnsParent = '';
		
		$parentRowColumnSelector = $this->parentRowColumnFieldName;//this property was set in FieldtypeMatrix getInputfield()
		$rowSelector = $this->rowSelector;//this property was set in FieldtypeMatrix getInputfield()
		$columnSelector = $this->columnSelector;//this property was set in FieldtypeMatrix getInputfield()
		
		$editURL = $this->wire('config')->urls->admin . 'setup/field/edit?id=' . $this->field->id;
		
		### first we deal with errors. We'll return these as strings to oupput in $this->error() in render() ###

		//in neither a Page Field nor selectors for finding pages to build matrix rows/columns specified set error message
		if((!$parentRowColumnSelector) && (!$rowSelector || !$columnSelector))			
				return '<a href="' . $editURL .'">' . 	$this->_('Check the Details Tab of the field') . '</a> ' . $this->field->name . 
														$this->_('. You need to either use selectors or a Page Field to find pages to show in your matrix table.');		

		//if Page Field specified, we use that to find the children pages of the specified row and column parent pages respectively
		if($parentRowColumnSelector) {							

				//if the page field does not return a PageArray, set error message	
				if(!$page->$parentRowColumnSelector instanceof PageArray)
					return '<a href="' . $editURL .'">' . 	$this->_('Check the Details Tab of the field') . '</a> ' . $this->field->name . 
															$this->_('. Only a Page Field can be used to specify the rows and columns parent pages for building your matrix! Confirm that you specified a Multiplepage Field.');

				//if less than 2 matrix parent pages selected (we need one for rows and the other for columns) set error message
				if(count($page->$parentRowColumnSelector) < 2) return $this->_('You need to select 1 matrix rows parent and 1 matrix columns parent.');

				### rows parent ###
				$rowsParent = $page->$parentRowColumnSelector->first();//the first selected page is treated as the row pages parent
				
				//if for some reason specified $rowsParent does not exist set error message
				if(!$rowsParent) return $this->_('The specified matrix row parent page was not found. Confirm it exists or specify another.');
				
				//if $rowsParent does not have children set error message
				if(!$rowsParent->numChildren) return $this->_('The specified matrix rows parent does not have children. You need to first create its child pages.');

				#### columns parent ####
				$columnsParent = $page->$parentRowColumnSelector->getNext($rowsParent);//the second selected page is treated as the column pages parent

				//if for some reason specified $columnsParent does not exist set error message
				if(!$columnsParent) return $this->_('The specified matrix columns parent page was not found. Confirm it exists or specify another.');
				
				//if $columnsParent does not have children set error message
				if(!$columnsParent->numChildren) return $this->_('The specified matrix column parent does not have children. You need to first create its child pages.');

				
				##### -if we made it here, we are good to go ####
				//find all matrix-row pages
				$rows = $rowsParent->children;

				//find all matrix-column pages
				$columns = $columnsParent->children;
	
		}//end if a Page Field was specified

		//if Page Field NOT specified, we use specified row/column selectors instead
		else {

				//find all matrix-row pages
				$rows = $pages->find($rowSelector);//ProcessWire will throw an exception here if the selector is not valid

				//find all matrix-column pages
				$columns = $pages->find($columnSelector);//ProcessWire will throw an exception here if the selector is not valid

				//if row/column selectors return empty set error message
				if(!count($rows)) 
					return 	$this->_('No row pages found with the selector set in \'Row Matrix pages\' for the field ') . $this->field->name . 
							'. <a href="' . $editURL .'">' . 	$this->_('Amend your selector') . '</a>.';
				
				if(!count($columns)) 
					return 	$this->_('No column pages found with the selector set in \'Column Matrix pages\' for the field ') . $this->field->name . 
							'. <a href="' . $editURL .'">' . 	$this->_('Amend your selector') . '</a>.';

		}//end else we use row/column selectors

		//create our default matrix with blank values (i.e. blank matrix->value)
		//we later merge this with saved values in the db
		//this will help us detect if new row/column pages have been added
		$defaultMatrix = array();

		//get the rows and columns to build our empty-values default matrix
		foreach($rows as $row) {

				//create our rows - top level array
				#$defaultMatrix[$row->id] = '';//no need for this here

				//create our columns - 2nd level array WITH empty values
				foreach($columns as $column) {
							
							$defaultMatrix[$row->id][$column->id] = '';//value = blank
				}

		}

		//get our saved db matrix values
		$dbMatrix = array();//for storing row/column values already saved in db

		//loop through saved db vakues
		foreach($values as $m) {

				//get the row page
				$rp = $pages->get($m->matrix_row);
				
				//in case the matrix rows parent was changed and is different from the rows parent of the saved db values...
				//we skip such rows in readiness for deletion
				//we only do this if a Page Field was used to select matrix rows (difficult if a selector was used - no problem since assuming only supersuser can edit selector in Page Field)
				if($rowsParent && $rp->parent != $rowsParent) continue;

				//remove matrix-rows that are no longer needed i.e. 'unpublished', 'hidden', 'deleted' or 'trashed'
				if(!$rp || $rp->is(Page::statusUnpublished) || $rp->isHidden() || $rp->isTrash()) continue;
				//if(!$rp || $rp->is('unpublished') || $rp->is('hidden')) continue;//syntax will only work in PW 2.5+ ?

				//build the saved values array
				#$dbMatrix[$m->matrix_row][$m->matrix_column] = $m->matrix_value;//
				$dbMatrix[$m->matrix_row][$m->matrix_column] = $this->sanitizer->entities($m->matrix_value);//@@todo - need to sanitize this values for display?

				//get the column page
				$cp = $pages->get($m->matrix_column);

				//remove matrix-columns that are no longer needed i.e. 'unpublished', 'hidden', 'deleted' or 'trashed'
				if(!$cp || $cp->is(Page::statusUnpublished) || $cp->isHidden() || $cp->isTrash()) unset($dbMatrix[$m->matrix_row][$m->matrix_column]);
				
				//in case the matrix columns parent was changed and is different from the columns parent of the saved db values...
				//we remove such columns in readiness for deletion
				//we only do this if a Page Field was used to select matrix columns (ditto above)
				if($columnsParent && $cp->parent != $columnsParent) unset($dbMatrix[$m->matrix_row][$m->matrix_column]);

		}

		//prepare our final matrix to output to page (edit) InputfieldMatrix
		//we recursively replace defaultMatrix blank values with dbMatrix values where applicable (matched array keys)
		//'new' (i.e. not in $dbMatrix) default row/column combinations are preserved and added to final matrix
		//note: values previously saved using a different selector will still be present!...
		//as long as their respective pages have not been deleted/trashed/hid/unpublished
		$mergedMatrix = array_replace_recursive($defaultMatrix, $dbMatrix);

		return $mergedMatrix;//matrix array

	}

	/**
	 * Render the entire input area for a Matrix
	 *
	 */
	public function ___render() {

		//#########	CREATE MATRIX TABLE #########

		$mergedMatrix = $this->mergeMatrix();

		//if we didn't get an array back from $mergeMatrix() it means errors were found. We output the returned 'error' strings
		if(!is_array($mergedMatrix)) {
			$this->error($mergedMatrix, Notice::allowMarkup);
			return;

		}

		$pages = wire('pages');

		$tbody ='';//for matrix rows
		$thcols = '';//for matrix table column headers
		$rowHeaderLabel = $this->rowLabelFieldName;//this property was set in FieldtypeMatrix getInputfield()
		$columnHeaderLabel = $this->columnLabelFieldName;//this property was set in FieldtypeMatrix getInputfield()
		//@@todo - saved $columnHeaderLabler not being displayed as selected in Details tab! But value is correctly saved in db

		$i = 0;//set counter not to output extraneous column label headers
		//$j = 1;//counter for rows numbering
		$count = '';//initialise variable for counting number of columns
		
		foreach($mergedMatrix as $row => $cols) {

	            //matrix table row headers (first column)
				$rh = $pages->get($row);//getting by page->id
	            #$tbody .= "<tr><td><strong>" . $pages->get($row)->title . "</strong></td>";
				
				//if we have a row label from selected field show it otherwise show title
	            $rowLabel = $rh->$rowHeaderLabel ? $rh->$rowHeaderLabel : $rh->title;
	           /*$tbody .= "<tr>
								<td class=MatrixRowCount>" . $j. "</td>
	            				<td>" . $rowLabel. "</td>";*///@@left here in case will switch to row counters in the future

	            $tbody .= "<tr><td class='MatrixRowHeader'>" . $rowLabel . "</td>";
            
	            //we count this once only rather than on each 'row' loop!
	            if($i == 0) $count = count($cols);//help to stop output of extra/duplicate column headers

	            foreach($cols as $col => $value) {

			            	//matrix table column headers
	            			$ch = $pages->get($col);//getting by page->id

	            			//if we have a column label from selected field show it otherwise show title
	            			$columnLabel = $ch->$columnHeaderLabel ? $ch->$columnHeaderLabel : $ch->title;
			            	
			            	//avoid outputting extra duplicate columns. 
			            	if($i < $count) {

				            		$thcols .= "<th class='MatrixColumnHeader'>" . $columnLabel  . "</th>";

									$i++;//no need to keep incrementing after number of desired columns reached

			            	}
			            		
			                //input name will be in the format 'R5282_C5289' to match row and column page IDs respectively
			                #$tbody .= "<td><input type='text' name='matrix[R" . $rh->id . "_C" . $ch->id . "]' value='" . $value . "'></td>";
			                $tbody .= "<td><input type='text' name='matrix_" . $this->field->name. "[R" . $rh->id . "_C" . $ch->id . "]' value='" . $value . "'></td>";				             	

	            }

	            $tbody .= "</tr>";	            

	            //$j++;
		}

		//final matrix table for output
		 $out =   "<table class='InputfieldMatrix'>
		                <thead>
		                  <tr class=''>
		                    <th></th>
		                    $thcols
		                   </tr>
		                </thead>
		                <tbody>
		                  $tbody
		                </tbody>
		            </table>";


		//Optionally enabled in FieltypeMatrix config: allow copy-pasting of CSV data @@todo - complete this!
		//paste CSV data options
		$inputfields = new InputfieldWrapper();

		$fieldset = $this->modules->get('InputfieldFieldset'); 
		$fieldset->attr('id', 'csv_import'); 
		$fieldset->label = "CSV Data";
		$fieldset->description = $this->_('If you prefer, you may paste in CSV data below rather than entering them manually to populate your matrix table above.');
		$fieldset->collapsed = Inputfield::collapsedYes;

        //csv delimeter
        $f = $this->modules->get('InputfieldText');
        $f->name = 'csv_column_separator';
        $f->label = $this->_('Columns delimited by');
        $f->notes = $this->_('For tab-separated, enter: tab.');
        $f->value = ',';
        #$f->columnWidth = 50;
        $fieldset->add($f);

        //csv enclosure
        $f = $this->modules->get('InputfieldText');
        $f->name = 'csv_column_enclosure';
        $f->label = $this->_('Column enclosure');
        $f->notes = $this->_('When a value contains a delimeter, it must be enclosed by a character (typically a double quote character). If you are not sure what should go here, it is recommended you leave it at the default (").');
        $f->value = '"';
		if($f->value == '"') $f->collapsed = Inputfield::collapsedYes;
        $f->attr('maxlength', 1); 
		$f->attr('size', 1); 
        #$f->columnWidth = 50;
        
        $fieldset->add($f);

		//csv paste
		$f = $this->modules->get('InputfieldTextarea');
        $f->name = "matrix_" . $this->field->name . "_csvdata";
        $f->label = $this->_('Paste in CSV Data');
		$f->description = $this->_('If you prefer, you may paste in CSV data here rather than entering them manually to populate your matrix table above. 
			Values entered here overwrite those in the matrix table!');
		$f->notes = $this->_('1. If you wish to import values for your whole matrix table, be sure that the number of rows and columns in your CSV data exactly match the matrix table above.
			2. Any extra rows/columns will be discarded. 
			3. However, you can also paste in CSV data with less rows/columns or with some missing values. 
			4. After saving, you will be able to manually input missing values and/or correct mistakes. 
			5. The CSV Data must not contain header rows.');        
       #$f->collapsed = Inputfield::collapsedYes;

        $fieldset->add($f);

        $inputfields->add($fieldset);

		return $out . $inputfields->render();
	}

	
	/**
	 * Process copy-pasted CSV matrix values
	 *
	 */

	public function processCSV($csvRawData, $csvDelimiter, $csvEnclosure) {

		//prepare some variables
		$pages = wire('pages');
		$page = $this->page;
		$rowsParent = '';
		$columnsParent = '';
		
		$parentRowColumnSelector = $this->parentRowColumnFieldName;//this property was set in FieldtypeMatrix getInputfield()
		$rowSelector = $this->rowSelector;//this property was set in FieldtypeMatrix getInputfield()
		$columnSelector = $this->columnSelector;//this property was set in FieldtypeMatrix getInputfield()

		//if Page Field specified, we use that to find the children pages of the specified row and column parent pages respectively (this will match what is already in the matrix table)
		if($parentRowColumnSelector) {

				//rows parent
				$rowsParent = $page->$parentRowColumnSelector->first();//the first selected page is treated as the row pages parent
		
				//columns parent
				$columnsParent = $page->$parentRowColumnSelector->getNext($rowsParent);//the second selected page is treated as the column pages parent
		
				//find all matrix-row pages
				$rowPages = $rowsParent->children;

				//find all matrix-column pages
				$columnPages = $columnsParent->children;

		}

		//if Page Field NOT specified, we use specified row/column selectors instead
		else {

				//find all matrix-row pages
				$rowPages = $pages->find($rowSelector);//ProcessWire will throw an exception here if the selector is not valid

				//find all matrix-column pages
				$columnPages = $pages->find($columnSelector);//ProcessWire will throw an exception here if the selector is not valid

		}

		foreach ($rowPages as $row)  $rows[] = $row->id;
		$cntRows = count($rows);

		foreach ($columnPages as $col)  $columns[] = $col->id;
		$cntCols = count($columns);

		//if no $csvDelimiter set, throw error, return! rather than assume default ',' [comma]
		if(!$csvDelimiter) {
				$this->error($this->_('A CSV delimiter has to be set!'));
				return;

		}

		//@@todo - enclosure = if not sent, assume double quote "?

		$data = array();
		$i = 0;//rows counter
		$j = 0;//columns counter

		foreach(explode("\n", $csvRawData) as $row){
		        
		       	$csvData = str_getcsv($row, $csvDelimiter == "tab" ? chr(9) : $csvDelimiter, $csvEnclosure);//check delimiter type here
		        //chr(9) is ASCII standard character for TAB

		        foreach ($csvData as $value) {
		                      
		            $data[$rows[$i]][$columns[$j]] = $value;
		            $j++;
		            if($j==$cntCols) break;//if csv data columns exceed columns in matrix we abort

		        }
		        
		        $i++;
		        $j=0;//reset the column counter for next loop
		        if($i==$cntRows) break;//if csv data rows exceed rows in matrix we abort
		
		}//enc foreach explode $csvRawData

        /****

    		Note: the array $data is in our defautlMatrix/dbMatrix format in $mergeMatrix(), i.e.

    		Array
			(

			    [5271] => Array 				//this key of the outer array is the row $page->id
			        (
			            [5282] => DVD Player 	//in the inner array, key = column $page->id and value = matrix intersection/cell
			            [5284] => Black
			            [5285] => Use
			            [5286] => 500
			        )

			    [5275] => Array
			        (
			            [5282] => Blu-Ray Player
			            [5284] => Silver
			            [5285] => New
			            [5286] => 800
			        )
			)

		***/

		$matrices = $this->field->type->getBlankValue($this->page, $this->field);

		foreach ($data as $row => $cols) {
		  
				#our row $page->id is key in the outer array
				#we repeat this for each inner column=>value pair
				#our column $page->id is the $column (the inner array key) and the matrix intersection/cell is the $value
				foreach ($cols as $column => $value) {
		         
			          if($value == '') continue;//skip empty records

			          //create a new matrix and add it to our matrices
			          $m = new Matrix();

			          $m->matrix_row = (int) $row;//@@todo - don't really need to sanitize here as well since done in Matrix::set() too?
			          $m->matrix_column = (int) $column;//@@todo - ditto
			          $m->matrix_value = $value;

			          $matrices->add($m);//add matrix to MatrixArray*/
			       

			       }//end foreach $cols as $column => $value
		      

		}//end foreach $data as $row => $cols

		return $matrices;
	

	}

	/**
	 * Process input for the values sent from the Matrix table for this page
	 *
	 */
	public function ___processInput(WireInputData $input) {

		if(!$this->page || !$this->field) {
			throw new WireException("This inputfield requires that you set valid 'page' and 'field' properties to it."); 
		}

		$name = 'matrix_' . $this->attr('name');

		//dealing with manually entered values
		if ($input->{"{$name}_csvdata"} == '') {

			$matrices = $this->field->type->getBlankValue($this->page, $this->field);
			
			foreach($input->{"{$name}"} as $key => $value) {
					
					//if value empty, we skip the record; no need to save empty values!
					if($value == '') continue;

					//$key is in the format R1234_C1234 reflecting row and column pages' IDs respectively
					$rowCol = explode('_', $key);//[0]=>R1234, [1]=>C1234

					$row = str_replace('R', NULL, $rowCol[0]);//clean row page ID
					$column = str_replace('C', NULL, $rowCol[1]);//clean column page ID

					//create a new matrix and add it to our matrices
					$m = new Matrix();

					$m->matrix_row = (int) $row;//@@todo - don't really need to sanitize here as well since done in Matrix::set() too?
					$m->matrix_column = (int) $column;//@@todo - ditto
					$m->matrix_value = $value;

					$matrices->add($m);//add matrix to MatrixArray

			}//end foreach


		}

		//dealing with csv values
		else {

					$csvRawData = $input->{"{$name}_csvdata"};
					$csvDelimiter = $input->csv_column_separator;
					$csvEnclosure = $input->csv_column_enclosure;

					$matrices = $this->processCSV($csvRawData, $csvDelimiter, $csvEnclosure);					
		}
	
		//if the string values of the processed matrices are different from the previous,
		//or if any matrices have been deleted, then flag this Inputfield as changed
		//so that it will be automatically saved with the page
		
		//if things have changed, we take the new values
		if("$matrices" != "$this->value") {
			
				$this->attr('value', $matrices); 
				$this->trackChange('value'); 
		}
		

	}


}

