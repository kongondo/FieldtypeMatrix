<?php

/**
* InputfieldMatrix for ProcessWire.
*
* This Inputfield is a GUI for FieldtypeMatrix.
*
* @author Kongondo <kongondo@gmail.com>
* @author Ryan Cramer 
* 
* Largely based on original code from Ryan Cramer's FieldtypeEvnents. 
*
* Lincensed under GNU/GPL v2.
*
* https://github.com/kongondo/FieldtypeMatrix
* Created December 2014
* 
* ProcessWire 2.x
* Copyright (C) 2011 by Ryan Cramer
* Licensed under GNU/GPL v2, see LICENSE.TXT
*
* http://www.processwire.com
*
*/

class InputfieldMatrix extends Inputfield {

	public static function getModuleInfo() {
		return array(
			'title' => 'Matrix',
			'author' => 'Kongondo',
			'version' => 2,
			'href' => 'https://processwire.com/talk/topic/8581-module-matrix-fieldtype-inputfield/',
			'summary' => 'Input field for a 2D-matrix.',
			'requires' => 'FieldtypeMatrix', 
			);
	}

	protected $page;
	protected $field; 

	public function setPage(Page $page) {
		
		$this->page = $page; 
	}

	public function setField(Field $field) {

		$this->field = $field;
	}

	/**
	 * Render the entire input area for a Matrix
	 *
	 */
	public function ___render() {

		//prepare some variables
		$values = $this->attr('value');
		$pages = wire('pages');
		$page = $this->page;
		$rowsParent = '';
		$columnsParent = '';
		
		$parentRowColumnSelector = $this->parentRowColumnFieldName;//this property was set in FieldtypeMatrix getInputfield()
		$rowSelector = $this->rows;//this property was set in FieldtypeMatrix getInputfield()
		$columnSelector = $this->columns;//this property was set in FieldtypeMatrix getInputfield()
		
		$editURL = $this->wire('config')->urls->admin . 'setup/field/edit?id=' . $this->field->id;

		//in neither a Page Field nor selectors for finding pages to build matrix rows/columns specified, return feedback to user
		//@@todo - use error instead?
		if((!$parentRowColumnSelector) && (!$rowSelector || !$columnSelector)) return '<h4>You need to either input selectors or a Page Field to find pages to show in your matrix table. See this <a href="' . $editURL .'">Field\'s Details Tab.</a></h4>';

		//if Page Field specified, we use that to find the children pages of the specified row and column parent pages respectively
		if ($parentRowColumnSelector) {
							
				### first we deal with errors ###

				//if the page field does not return a PageArray, we throw an error, return		
				if(!$page->$parentRowColumnSelector instanceof PageArray) {

					$this->error($this->_('Only a Page Field can be used to specify the rows and columns parent pages for building your matrix! Confirm that you specified a Multiplepage Field for this Field. See this <a href="' . $editURL .'">Field\'s Details Tab.</a>'), Notice::allowMarkup);
					return;

				}

				//if less than 2 matrix parent pages selected (we need one for rows and the other for columns), throw an error, return
				if(count($page->$parentRowColumnSelector) < 2) {

					$this->error($this->_('You need to select 1 matrix rows parent and 1 matrix columns parent.'));
					return;

				}

				### rows parent ###
				$rowsParent = $page->$parentRowColumnSelector->first();//the first selected page is treated as the row pages parent
				
				//if for some reason specified $rowsParent does not exist throw an error, return
				if(!$rowsParent) {

					$this->error($this->_('The specified matrix row parent page was not found. Confirm it exists or specify another.'));
					return;

				}
				
				//if $rowsParent does not have children, throw an error, return
				if(!$rowsParent->numChildren) {

					$this->error($this->_('The specified matrix rows parent does not have children. You need to first create its child pages.'));
					return;

				}

				#### columns parent ####
				$columnsParent = $page->$parentRowColumnSelector->getNext($rowsParent);//the second selected page is treated as the column pages parent

				//if for some reason specified $columnsParent does not exist throw an error, return
				if(!$columnsParent) {

					$this->error($this->_('The specified matrix columns parent page was not found. Confirm it exists or specify another.'));
					return;

				}
				
				//if $columnsParent does not have children, throw an error, return
				if(!$columnsParent->numChildren) {

					$this->error($this->_('The specified matrix column parent does not have children. You need to first create its child pages.'));
					return;

				}
				
				##### -if we made it here, we are good to go ####
				//find all matrix-row pages
				$rows = $rowsParent->children;

				//find all matrix-column pages
				$columns = $columnsParent->children;
	
		}//end if a Page Field was specified

		//if Page Field not specified, we use specified row/column selectors instead
		else {

				//find all matrix-row pages
				$rows = $pages->find($rowSelector); //ProcessWire will throw an exception here if the selector is not valid

				//find all matrix-column pages
				$columns = $pages->find($columnSelector); //ProcessWire will throw an exception here if the selector is not valid

				//throw error if row selector returns empty!
				if (!count($rows)) {
							$this->error($this->_('No row pages found with the selector set in \'Row Matrix pages\' for this Field. Amend your selector.'));
							return '<h4>Rows selector did not find any results!</h4>';
				}

				//throw error if column selector returns empty!
				if (!count($columns)) {
							$this->error($this->_('No column pages found with the selector set in \'Column Matrix\' pages for this Field. Amend your selector.'));
							return '<h4>Columns selector did not find any results!</h4>';
				}


		}//end else we use row/column selectors
		
		
		//creat our default matrix with blank values (i.e. blank matrix->value)
		$defaultMatrix = array();

		//get the rows and columns to build our empty-values default matrix
		foreach($rows as $row) {

					//create our rows - top level array
					$defaultMatrix[$row->id] = '';

					//create our columns - 2nd level array WITH empty values
					foreach ($columns as $column) {
								
								$defaultMatrix[$row->id][$column->id] = '';//value = blank
					}

		}

		//get our db saved matrix values
		$dbMatrix = array();//for storing row/column values already saved in db

		foreach($values as $m) {

						//get the row page
						$rp = $pages->get($m->matrix_row);
						
						//in case the matrix rows parent was changed and is different from the rows parent of the saved db values
						//we skip such rows in readiness for deletion
						//we only do this if a Page Field was used to select matrix rows (difficult if a selector was used - no problem since assuming only supersuser can edit selector in Page Field)
						if($rowsParent && $rp->parent != $rowsParent) continue;

						//remove matrix-rows that are no longer needed i.e. 'unpublished', 'hidden', 'deleted' or 'trashed'
						if (!$rp || $rp->is(Page::statusUnpublished) || $rp->isHidden() || $rp->isTrash()) continue;
						//if (!$rp || $rp->is('unpublished') || $rp->is('hidden')) continue;//syntax will only work in PW 2.5+ ?

						$dbMatrix[$m->matrix_row][$m->matrix_column] = $m->matrix_value;

						//get the column page
						$cp = $pages->get($m->matrix_column);

						//remove matrix-columns that are no longer needed i.e. 'unpublished', 'hidden', 'deleted' or 'trashed'
						if (!$cp || $cp->is(Page::statusUnpublished) || $cp->isHidden() || $cp->isTrash()) unset($dbMatrix[$m->matrix_row][$m->matrix_column]);
						
						//in case the matrix columns parent was changed and is different from the columns parent of the saved db values
						//we remove such columns in readiness for deletion
						//we only do this if a Page Field was used to select matrix columns (ditto above)
						if($columnsParent && $cp->parent != $columnsParent) unset($dbMatrix[$m->matrix_row][$m->matrix_column]);

		}

		//#########	CREATE MATRIX TABLE #########

		//prepare our final matrix to output to page edit InputfieldMatrix
		//we recursively replace defaultMatrix blank values with dbMatrix values where applicable (matched array keys)
		//'new' (i.e. not in $dbMatrix) default row/column combinations are preserved and added to final matrix
		//note: values previously saved using a different selector will still be present!
		//as long as their respective pages have not been deleted/trashed/hid/unpublished
		$mergedMatrix = array_replace_recursive($defaultMatrix, $dbMatrix);		

		$tbody ='';//for matrix rows
		$thcols = '';//for matrix table column headers
		$rowHeaderLabel = $this->rowLabelFieldName;//this property was set in FieldtypeMatrix getInputfield()
		$columnHeaderLabel = $this->columnLabelFieldName;//this property was set in FieldtypeMatrix getInputfield()
		//@@todo - saved $columnHeaderLabler not being displayed as selected in Details tab! But value is correctly saved in db

		$i = 0;//set counter not to output extraneous column label headers
		//$j = 1;//counter for rows numbering
		foreach ($mergedMatrix as $row => $cols) {

		            //matrix table row headers (first column)
					$rh = $pages->get($row);
		            #$tbody .= "<tr><td><strong>" . $pages->get($row)->title . "</strong></td>";
					
					//if we have a row label from selected field show it otherwise show title
		            $rowLabel = $rh->$rowHeaderLabel ? $rh->$rowHeaderLabel : $rh->title;
		           /*$tbody .= "<tr>
									<td class=MatrixRowCount>" . $j. "</td>
		            				<td>" . $rowLabel. "</td>";*///@@left here in case will switch to row counters in the future

		            $tbody .= "<tr><td class='MatrixRowHeader'>" . $rowLabel . "</td>";

		            $count = count($cols);//help to stop output of extra/duplicate column headers

		            foreach ($cols as $col => $value) {

				            	//matrix table column headers
		            			$ch = $pages->get($col);

		            			//if we have a column label from selected field show it otherwise show title
		            			$columnLabel = $ch->$columnHeaderLabel ? $ch->$columnHeaderLabel : $ch->title;
				            	//avoid outputting extra duplicate columns
				            	if ($i < $count) $thcols .= "<th class='MatrixColumnHeader'>" . $columnLabel . "</th>";
				            		
				                //input name will be in the format 'R5282_C5289' to match row and column page IDs respectively
				                #$tbody .= "<td><input type='text' name='matrix[R" . $rh->id . "_C" . $ch->id . "]' value='" . $value . "'></td>";
				                $tbody .= "<td><input type='text' name='matrix_" . $this->field->name. "[R" . $rh->id . "_C" . $ch->id . "]' value='" . $value . "'></td>";
				             	
				             	$i++;

		            }

		            $tbody .= "</tr>";

		            //$j++;
		}

		//final matrix table for output
		 $out =   "<table class='InputfieldMatrix'>
		                <thead>
		                  <tr class=''>
		                    <th></th>
		                    $thcols
		                   </tr>
		                </thead>
		                <tbody>
		                  $tbody
		                </tbody>
		            </table>";


		return $out; 
	}

	/**
	 * Process input for the values sent from the Matrix table for this page
	 *
	 */
	public function ___processInput(WireInputData $input) {

			if(!$this->page || !$this->field) {
				throw new WireException("This inputfield requires that you set valid 'page' and 'field' properties to it."); 
			}

			$name = 'matrix_' . $this->attr('name');

			$matrices = $this->field->type->getBlankValue($this->page, $this->field);

			foreach ($input->{"{$name}"} as $key => $value) {

					//$key is in the format R1234_C1234 reflecting row and column pages' IDs respectively
						
					//create a new matrix and add it to our matrices
					$m = new Matrix();

					$rowCol = explode('_', $key);//[0]=>R1234, [1]=>C1234

					$row = str_replace('R', NULL, $rowCol[0]);//clean row page ID
					$column = str_replace('C', NULL, $rowCol[1]);//clean column page ID

					$m->matrix_row = (int) $row;//@@todo - don't really need to sanitize here as well since done in Matrix::set() too?
					$m->matrix_column = (int) $column;//@@todo - ditto
					$m->matrix_value = $value;

					$matrices->add($m);//add matrix to MatrixArray

			}//end foreach
		
		//if the string values of the processed matrices are different from the previous,
		//or if any matrices have been deleted, then flag this Inputfield as changed
		//so that it will be automatically saved with the page
		
		//if things have changed, we take the new values
		if("$matrices" != "$this->value") {
			
				$this->attr('value', $matrices); 
				$this->trackChange('value'); 
		}
		

	}


}

